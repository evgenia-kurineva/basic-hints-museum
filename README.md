# Советы по выполнению задания Museum
- [ссылка на задание](museum-stage1.md)

0. [Организация работы](#0-организация-работы)
1. [Работа с репозиторием](#1-работа-с-репозиторием)
2. [Структура проекта](#2-cтруктура-проекта)
3. [Экспорт изображений](#3-экспорт-изображений-из-figma-растровая-и-векторная-графика)
4. [Советы по коду](#4-советы-по-коду)
5. [Подключение шрифтов](#5-подключение-шрифтов)
6. [Вёрстка основных блоков](#6-вёрстка-основных-блоков)
7. [Контейнер](#7-контейнер)
8. [Header](#8-header)
9. [Секция Welcome](#9-секция-welcome)
10. [Секция Visiting](#10-секция-visiting)
11. [Секция Explore](#11-секция-explore)
12. [Секция Video](#12-секция-video)
13. [Секция Tickets](#13-секция-tickets)
14. [Секция Contacts](#14-секция-contacts)
15. [CSS переменные](#15-css-переменные)

#### 0. Организация работы
- выполнение задания начните с изучения ТЗ. Не приступайте к работе над проектом без чёткого понимания, какой результат от вас ожидается
- разбейте задание на небольшие подзадачи. Выполняйте их последовательно
- ведите тайминг времени. Для учёта времени используйте [trello](https://netology.ru/blog/trello), с дополнением [Activity](https://texterra.ru/blog/prokachay-svoy-trello-rasshireniy-i-integratsiy-dlya-produktivnoy-raboty.html) (одно улучшение к доске с проектом можно подключить бесплатно). Так выглядит [доска trello](../images/trello.png) с выполненным проектом
- для проверки соответствия своей работы требованиям задания используйте 
  - расширение [PerfectPixel](https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru) для проверки соответствия вёрстки макету
  - сервис https://validator.w3.org/ для проверки валидности вёрстки

#### 1. Работа с репозиторием
- регистрируемся в rs app https://app.rs.school/registry/student
- заходим в dashboard, кликаем на кнопку `Create repo`
- на привязанную к гитхабу почту приходит инвайт - приглашение в приватный репозиторий школы. Принять инвайт необходимо сразу, через несколько дней он становится недействительным
- клонируем приватный репозиторий школы на свой компьютер  
`git clone ссылка на репозиторий` - ссылку копируем из адресной строки
- заходим в папку локального репозиторий командой `cd repo-name` или просто кликнув по ней мышкой и открыв GitBash внутри папки
- от ветки `main` создаём ветку `museum` и переходим в неё  
`git checkout -b "museum"`
- в ветке `museum` локального репозитория создаём папку museum, в ней размещаем файлы проекта
- в ходе работы над проектом, каждый выполненный этап работы пушим в удалённый репозиторий.  
Пример:
  ```
  git add .
  git commit -m "feat: add header"
  git push origin museum
  ```

#### 2. Структура проекта
В папке `museum` создайте файлы
- `index.html`
- `style.css`  
И папку
- `assets` с подпапками `img`, `svg`, `fonts`, `video` для хранения изображений, иконок, шрифтов и видео соответственно.  
Обратите внимание:
- файл `index.html` всегда находится на верхнем уровне (не вложенный в другую папку)
- файлы `style.css` и `index.js` находятся на верхнем уровне, если их только по одному.  
  Если таких файлов несколько, они размещаются внутри папок `css` и `js`

#### 3. Экспорт изображений из figma. Растровая и векторная графика
Чтобы экспортировать изображение из figma:
- кликните по нему - изображение выделится синей рамкой
- убедитесь, что справа выбрана вкладка **Design**
- справа внизу кликните по знаку "+" возле **Export**
- выберите формат, в котором экспортируется графика
  - обычные изображения - .jpg
  - изображения с текстом или прозрачностью - .png
  - иконки - .svg
- Кликните по кнопке **Export** внизу  

Чтобы экспортировать несколько изображений одновременно, выделяйте изображения с зажатой клавишей `Shift`, затем укажите формат для экспорта изображений и нажмите кнопку **Export**.

#### 4. Советы по коду  
1. Редактор кода.  
  Не пишите код в блокноте. Редактор кода с подсветкой кода, автодополнением, автоматическим закрытием скобок, автоматическим форматированием и полезными расширениями позволит вам писать код значительно быстрее и с меньшим количеством ошибок.
2. EMMET  
  Одно из самых полезных расширений существенно облегчающее и ускоряющее работу. EMMET невероятно популярен и уже интегрирован в VS Code. Изучите хотя бы несколько часто используемых в нём сокращений и постепенно расширяйте их список.
    <details>
      <summary>Некоторые сокращения EMMET</summary>

    Вёрстка - файл с расширением .html
      - `! + Tab` - выведет основу html документа
      - `link + Tab` = `<link rel="stylesheet" href="">` (подключение стилей)
      - `.container + Tab` = `<div class="container">`
      - `а + Tab` = `<a href=""></a>` - вместо `a` может быть любой другой тег
      - `a.card + Tab` = `<a href="" class="card"></a>` - через точку указываем название класса
      - `ul>li*3 + Tab` - выводится ненумерованный список с тремя пунктами
      - `ul.nav-list>li.nav-item*3>a.nav-link + Tab` - ненумерованный список с классом `nav-list` с тремя пунктами с классом `nav-item` внутри каждого из которых ссылка с классом `nav-link`

    Стили - файл с расширением .css
      - `m10 + Tab` = `margin: 10px;`
      - `bgc + Tab` = `background-color:`
      - `bgi + Tab` = `background-image: url();`
    </details>

3. Два пробела.  
  Когда-то разработчики долго спорили как разделять строки кода, использовать "табы или пробелы". Спор однозначно решился в пользу пробелов. Когда вы нажимаете на `Enter`, VS Code автоматически преобразует его в пробелы. Будет их два или четыре  определяется настройками. В профессиональной разработке преимущественно используют два пробела. 
4. Двойные кавычки  
  В html и css используйте двойные кавычки, в js - одинарные.
5. Семантические теги  
  Везде, где это возможно, используйте семантические теги, предложенные стандартом HTML5
6. Система заголовков  
  На странице обязательно должен быть один и только один заголовок h1. Заголовки более низкого порядка - h2-h6 - используйте для названий секций, названий карточек, подзаголовков в названиях карточек и.т.д.
7. Абсолютное позиционирование  
  Будьте осторожны с использованием абсолютного позиционирования. Оно подходит для вёрстки небольших элементов, но никогда не используется для вёрстки сетки. Сделать такую сетку адаптивной будет невероятно сложно
8. Ненумерованные списки  
  Однотипные элементы с небольшим количеством контента верстаются ненумерованным списком. В предложенном макете списком верстаются пункты меню, ссылки на социальные сети, радиокнопки в блоке Buy tickets
9. Сложные селекторы  
  Чем меньше их будет в вашем коде, тем он понятнее и проще в поддержке. Указывайте элементам названия классов и стилизуйте классы.
10. Осмысленные имена классов  
  Будете вы использовать БЭМ или нет ваш выбор, но названия классов должны подсказать другим программистам и вам будущему за что этот элемент отвечает.  
  Названия классов описывают не то, как выглядит элемент или где он находится на странице, а его функционал. [Слова, часто используемые в CSS-классах](https://github.com/yoksel/common-words).  
  Не используйте транслит в названиях классов: `link`, `list` - хорошо, ~~`ssilka`~~, ~~`spisok`~~ - фейл.
11. Порядок определения стилей  
- позиционирование
- блочная модель
- типографика
- оформление
- анимация
12. Всё в пикселях  
  Все размеры указывайте в пикселях, в т.ч и размер шрифта.  
  P.S. Проценты можно.

#### 5. Подключение шрифтов
**Через Google Fonts**  
- переходим по ссылке https://fonts.google.com/
- в поиске указываем нужный шрифт, например, Roboto
- кликаем по нужному шрифту
- кликаем по знаку "+" возле каждого используемого в макете стиля шрифта
- копируем код 
  ```
  <link rel="preconnect" href="https://fonts.gstatic.com">  
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;500;700&display=swap" rel="stylesheet">
  ```
- вставляем скопированный код в блок head index.html

**Подключение локальных шрифтов**  
- скачиваем шрифт на компьютер, помещаем в папку `fonts`
- подключаем шрифт в самом начале файла `style.css`
```css
@font-face {
 font-family: Roboto;
  src: url("assets/fonts/Roboto.ttf");
}
```
- если нужно подключить несколько файлов с шрифтом с разной насыщенностью
```css
@font-face {
  font-family: Roboto;
  src: url("assets/fonts/RobotoThin.ttf");
  font-weight: 100;
}
@font-face {
  font-family: Roboto;
  src: url("assets/fonts/RobotoRegular.ttf");
  font-weight: 300;
}
```

В figma есть проблема с определением свойства `font-weight` шрифта. Чтобы её решить, можно или установить в figma плагин [Font Fascia](https://www.figma.com/community/plugin/746097413727734148/Font-Fascia), или прокрутить свойства шрифта [чуть ниже](https://raw.githubusercontent.com/rolling-scopes-school/tasks/master/tasks/images/figma-font-weight.png) 

#### 6. Вёрстка основных блоков
В файле `index.html` нажимаем восклицательный знак и `Tab` - готова основа html документа.  
В блоке `head` указываем `title` - заголовок страницы:
```html
<title>museum</title>
``` 
подключаем стили:
```html
<link rel="stylesheet" href="style.css" />
```
подключаем фавикон - значок сайта
```html
<link rel="icon" href="assets/favicon.ico">
```
В блоке `body` создаём блоки `<header>`, `<main>` и `<footer>`, внутри блока `<main>` создаём шесть секций. Пока у них нет содержимого, блоки и секции не отображаются на странице. Чтобы увидеть добавленные элементы, в css им можно указать границу `border: 1px solid red;`.

Обратите внимание: блоки и секции не должны иметь внешние отступы `margin`. Этим обеспечивается возможность изменения их взаимного положения на странице, использования в других проектах, работы над проектом нескольких человек.

О названиях классов. Если вы уверены, что `<header>`, `<main>` и `<footer>` на странице будут только одни, можно указать название класса такое же, как название тега: `<header class = "header">`. Иначе, указываем название класса "page-header".

Для секций нам понадобится указать несколько классов, например, "section, dark-section, video-section". Для первого класса указываем общие для всех секций свойства - верхний и нижний padding 75px, для второго - тёмных фоновый цвет некоторых секций, для третьего - отличие данной секции от остальных - верхний padding 90px, а не 75. Указывая несколько классов каждой секции, мы сокращаем дублирование кода: без этого нам нужно было бы для каждой секции указать значения отступов и фонового цвета. Чем меньше кода, тем меньше в нём ошибок и тем легче будет вносить в него правки.

#### 7. Контейнер
Контейнер - `<div class="container">` размещается внутри каждого блока и каждой секции. Его задача - центрировать содержимое и ограничить его ширину.  
Расположить контейнер и его содержимое по центру позволит свойство `margin: 0 auto;`.  
На этапе фиксированной вёрстки достаточно указать ширину контейнера `width: 1440px;`.  
На этапе адаптивной вёрстки укажем для контейнера свойство `max-width: 1440px;`. Как любой блочный элемент он стремится занять всю ширину окна браузера. Так и происходит до тех пор, пока ширина окна не превышает 1440px, если окно браузера больше, мы ограничиваем ширину контейнера.  

#### 8. Header
В блоке `header` два элемента: логотип и навигация.  
Чтобы разместить их по горизонтали используем флексбоксы. С флексбоксами желательно познакомиться поближе, это полезная и удобная технология. Пример использования флексбоксов:
```css
.header-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}
```
Мы указали контейнеру дополнительный класс `.header-container`, указали ему свойство `display: flex;`, превратив его в флекс-контейнер, и выровняли содержимое по оси Х и по оси Y:
- `justify-content: space-between;` - флекс-элементы равномерно распределяются по всей строке. Первый и последний элемент прижимаются к соответствующим краям контейнера.
- `align-items: center;` - флекс-элементы размещаются по центру по высоте.

**Логотип**  
Логотип состоит из иконки и текста.  
Иконки экспортируются из figma и добавляются на страницу в векторном формате .svg.  
Как правильно добавлять иконку фоновым изображением при помощи свойства `background-image` или тегом `img`?  
Общее правило: через тег `img` добавляются значимые изображения, являющиеся частью контента сайта. Изображения, которые используются для оформления сайта, добавляются свойством `background-image`.  
Для добавления изображений иконок используется свойство `background-image`. Адрес svg-файлов указывается точно так же, как адрес растровых изображений:
```css
background-image: url("assets/svg/logo.svg");
```
Интерактивность при наведении такой иконке можно добавить при помощи css-фильтров.  
Генератор фильтра для получения заданного цвета: https://pranjaldubey.com/css-filter-generator/  
Так как генератор работает для черного цвета, а у нас белый, значение яркости нужно уменьшить.  
Ещё один способ изменить стиль svg при наведении - использование css-маски [Демо](https://codepen.io/irinainina/pen/abvGBwP)  

Что касается текста, обратите внимание, что в вёрстке текст пишется по правилам русского языка - первая буква заглавная, остальные - строчные. Если по замыслу дизайнера текст на странице отображается только заглавными, для этого используем css-свойство `text-transform: uppercase;`

**Навигация**  
Для вёрстки навигации используем семантический тег `nav` в который вкладываем ненумерованный список.  
Сброс стилей списка:
```css
li{
  list-style: none;
}
```
Тегу `ul` задаём свойство `display: flex;` и выравниваем пункты меню по горизонтали и вертикали.

Ширина навигации на макете составляет 720px. Но, как и с шириной контейнера, указать точную ширину навигации означает создать проблемы с адаптивностью. Лучше использовать свойство `max-width: 720px;`.

Элементам навигации необходимо добавить паддинги по бокам, чтобы они не слипались при уменьшении ширины страницы, высоту строки указываем равной высоте навигации. До появления флексбоксов это свойство использовалось для выравнивания текста по вертикали, в нашем случае оно делает меню более удобным: размер пункта меню становится больше и для перехода по ссылке пользователю не обязательно кликать точно по её тексту.

**Прокрутка по якорям**  
Ссылка в пункте меню выглядит так
```html
<a href="#visiting">Visiting</a>
```
Чтобы эта ссылка сработала, секции `Visiting` нужно указать соответствующий id:
```html
<section class="section visiting-section" id="visiting">
```
А чтобы прокрутка происходила плавно, элементу `html` указываем css-свойство `scroll-behavior: smooth;`

#### 9. Секция Welcome
В этой секции используются теги заголовка и параграфа.  
Обратите внимание на общие свойства всех заголовков секций на странице, вынесите их в общий класс `section-title`. Второй класс добавьте для стилизации заголовков тёмных секций.

Кнопку верстаем тегом `<a>`, если она ведёт на другую страницу, или тегом `<button>`, если при клике пользователь остаётся на текущей странице.  
В качестве возможного варианта функционала кнопки `Discover the Louvre` может быть переход по ссылке на [панораму музея](https://www.google.com/maps/@48.8618159,2.3366818,3a,75y,81.55h,73.4t/data=!3m7!1e1!3m5!1sAF1QipOVxZQuSy3Bx9T_HpH_7FtBHDTXvI6SF-A10ocT!2e10!3e12!7i5472!8i2736). В таком случае она верстается тегом `<a>`. Но так как данный момент в задании не оговаривается, реализация кнопки `Discover the Louvre` тегом `<button>` также допустима.

Сложность может представлять положение фонового изображения. На ширине страницы 1920px оно прижато к правому краю, но если разрешение экрана будет больше, изображение должно оставаться на своём месте, а не сдвигаться в сторону. Для управления положением фонового изображения на странице используйте свойство `background-position` с функцией `calc()`. Например (числа указаны произвольные):
```css
background-position: calc(100% - 20px) calc(100% - 10px);
```

#### 10. Секция Visiting
Заголовок секции вы уже стилизовали, когда работали над предыдущим блоком. Осталось только добавить к нему нижнее подчёркивание. Так как заголовков с подчёркиванием на макете несколько, для их стилизации создаём отдельный класс. Подчёркивание можно реализовать как свойством `border-bottom`, так и при помощи псевдоэлемента. Второй подход для данного макета кажется более типовым, так как в заголовках карточек тоже есть черта под заголовком, но там она занимает только часть ширины текста и это определённо не подчёркивание, а псевдоэлемент.

Псевдоэлемент в вёрстке это какой-то элемент оформления, который привязан к родительскому элементу. Псевдоэлементов может быть два `::before`, `::after`.  
Для псевдоэлементов часто используется абсолютное позиционирование, которое позволяет очень точно их разместить относительно родительского элемента и при этом не влиять на положение других элементов: псевдоэлемент выпадает из общего потока документа.

Пример кода:
```css
.underline-title {
  position: relative;
}
.underline-title::after {
  content: "";
  position: absolute;
  bottom: -25px;
  left: 0;
  right: 0;
  height: 3px;
  background-color: red;
}
```
Родительскому элементу указываем относительное позиционирование, иначе абсолютно позиционированный элемент будет выравниваться не относительно него, а относительно страницы. Свойства `left: 0; right: 0;` растянули псевдоэлемент во всю ширину родительского элемента, их можно заменить на `left: 0; width: 100%;`

Для карточек создаём ещё один контейнер. Вообще, лишние обёртки старайтесь не добавлять, но в данном случае отдельный контейнер для карточек необходим и оправдан.  
Для контейнера указываем максимальную ширину и свойство `display: flex;`. Выравниваем карточки внутри контейнера. Чтобы карточки переносились на следующую строку, используем свойство `flex-wrap: wrap;`. Это свойство обеспечивает в том числе и адаптивность: при уменьшении ширины страницы карточки сами переносятся на новые строки.  
Чтобы при уменьшении ширины страницы карточки не прижимались друг к другу, необходимо указать отступы между ними. Для этого удобно использовать свойство `gap`, которое добавляется контейнеру и определяет минимальное расстояние между вложенными в него flex-элементами.  
Свойство `gap` сокращенное, оно объединяет в себе `row-gap` и `column-gap`, благодаря чему можно указать разное расстояние между колонками и рядами flex-элементов.

Карточки верстаются ссылками, так как в будущем планируется, что каждая карточка будет перенаправлять на страницу с панорамой музея. Ссылка это [исключение](https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-a-element) из общего правила, по которому в строчный элемент нельзя вкладывать блочный: в ссылку вкладывать блочные элементы можно.  
Как и для любого другого строчного элемента, для ссылки не работают указанные в css ширина и высота, вертикальные отступы. Чтобы обойти это ограничение, достаточно указать строчному элементу свойство `display: block;`.

Карточка состоит из изображения, добавляемого через тег `img`, заголовка карточки и текста, добавляемого через тег `p`.  
Для изображений необходимо указывать их размеры - ширину и высоту. Это нужно для того, чтобы браузер оставлял для них свободное место, и когда картинка загрузится, она добавлялась на уже отведённое для неё место.  
Также для изображений указываем обязательный атрибут alt. Он отображается в тех случаях. если картинка не загрузилась, а также важен для обеспечения доступности сайта.

Сначала сверстайте одну карточку, затем скопируйте её код и добавьте ещё пять карточек, в которых нужно будет изменить только ссылку на изображение и название. Повторяющиеся элементы страницы можно добавлять через JavaScript, как это сделать разберём на stage1.

#### 11. Секция Explore
Контейнеру секции добавляем свойство `display: flex;`. Описание картины вместе с заголовком секции объединяем в один блок. Текст верстаем абзацами, текст другого цвета внутри абзаца верстаем тегом `span`.  
На этапе добавления JavaScript на месте изображения появится слайдер сравнения изображений до и после реставрации, пока это просто картинка с фиксированными размерами.  
В процессе добавления адаптивности размеры изображения - ширину и высоту - укажем в процентах, а затем перестроим блок, добавив контейнеру свойство `flex-direction: column;` благодаря которому заголовок и описание разместятся над изображением.

#### 12. Секция Video
С появлением HTML5 добавление видео на страницу стало рядовой задачей. Код видеоплеера
```html
<video src="assets/video/video.mp4" poster="assets/video/poster.jpg" controls></video>
```
Стандартный видеоплеер браузера внешне отличается от видеоплеера макета. Добавление кастомного видеоплеера реализуется при помощи JavaScript.  
На данном этапе задача добавления видео не ставится. Верстаем только картинку постера и панель управления.  
Прогресс-бар и регулятор громкости верстаются при помощи тега `input type="range"`. Для его стилизации уместно использование JavaScript. [Пример стилизации ползунка](https://codepen.io/irinainina/pen/wvJQWYR)

#### 13. Секция Tickets
Заголовок и картинка проблем доставить не должны.  
Пункты в блоке "Ticket Type" это радиокнопки - элемент `input type="radio"`. [Пример стилизации радиокнопок](https://www.w3schools.com/howto/tryit.asp?filename=tryhow_css_custom_radio)  
Пункты в блоке "Amount" это кнопки и элемент `input type="number"`. [Пример вёрстки](https://codepen.io/irinainina/pen/rNyWoOB)  

#### 14. Секция Contacts
Карта верстается картинкой. На этапе stage1 её заменит интерактивная карта из библиотеки mapbox

#### 15. CSS переменные
Часто встречающиеся в макете цвета, отступы, размеры можно передать в переменные и использовать эти переменные при стилизации.  
В начале файла со стилями объявляем переменные
```css
:root {
  --bg-dark: #151719;
  --dark-red: #710707;
  --font-gold: #9d8665;
  --font1: 80px;
  --font2: 32px;
}
```
Их использование:
```css
.section-title {
  font-size: var(--font1);
  color: var(--font-gold);
}
```
Преимущества:
- говорящие имена переменных запомнить легче, чем коды цветов или размеры шрифтов
- ключевые переменные сосредотачиваются в одном месте, в коде появляется "единый источник истины"
- очень легко и быстро вносить правки, предложение заказчика "поиграть со шрифтами" перестаёт быть проблемой
- удобно изменить свойства в медиа-запросе, например
```css
@media (max-width: 1024px) {
  :root {
    --font1: 50px;
    --font2: 28px;
  }
```

## Советы по выполнению задания Museum Stage#1
- [ссылка на задание](museum-stage1.md)

1. [Section Welcome. Slider](#1-section-welcome-slider)
2. [Section Visiting. Google Street View](#2-section-visiting-google-street-view)
3. [Section Video. Playlist](#3-section-video-playlist)
4. [Section Gallery. HTML](#4-section-gallery)
5. [Section Gallery. JavaScript](#5-section-gallery-javascript)
6. [Booking ticket form](#6-booking-ticket-form)
7. [Parallax](#7-parallax)
8. [JS-modules](#8-js-modules)
9. [Webpack](#9-webpack)

#### 1. Section Welcome. Slider
Уже на этапе вёрстки вам необходимо определиться какой слайдер вы будете использовать в своём проекте: 1) созданный самостоятельно, 2) подключаемый при помощи библиотеки.

**Создание собственного слайдера**

В случае создания собственного слайдера, вам необходимо будет выделить время на самостоятельное написание его кода, при этом структура проекта и особенности его работы вам будут полностью понятными. Именно этот путь рекомендуется студентам, стремящимся разобраться с js более глубоко.

Если вы нацелены на создание собственного слайдера, предлагаю вашему вниманию несколько туториалов от разных авторов как на русском, так и на английском языке, в видео и текстовом формате с кодом проектов и демо. Автор первого из них - Сергей Шаляпин - ментор rs school.
- [Swiper & Slider Examples (carousel live coding)](https://youtu.be/rkz6LURkbBw) - [код](https://www.dropbox.com/s/0g5c0qz69keig6s/carusel-swiper.zip?dl=0)
- [Делаем слайдер на чистом JavaScript с нуля](https://youtu.be/K3E1OfQuJ0Q) - [код и демо](https://github.com/Eremeow138/wayup-slider-js)
- [Infinite pure Javascript slider](https://medium.com/@claudiaconceic/infinite-plain-javascript-slider-click-and-touch-events-540c8bd174f2) - [код и демо](https://codepen.io/cconceicao/pen/PBQawy)

Обратите внимание, что автоматическая смена слайдов по условиям задания не требуется, зато необходима возможность пролистывать слайдер не только кликами по стрелкам и буллетам (кружочки или квадратики под слайдером), но и свайпами (движениями) мышки.

**Использование библиотеки**

Если предполагаете использовать готовый слайдер, подключаемый при помощи библиотеки, значительное время может уйти на то, чтобы разобраться с особенностями её работы, а также на поиск путей решения возможных проблем и ошибок, которые могут возникнуть. 

Слайдеров, подключаемых при помощи библиотек, существует много. Из наиболее популярных можно назвать
- [Tiny Slider](http://ganlanyuan.github.io/tiny-slider/demo/) - [Документация](https://github.com/ganlanyuan/tiny-slider#tiny-slider-2)
- [Slick Slider](https://kenwheeler.github.io/slick/) - [Документация](https://github.com/kenwheeler/slick#slick)
- [Swiper](https://swiperjs.com/demos) - [Документация](https://swiperjs.com/swiper-api)

Так как эти слайдеры достаточно популярны, на YouTube можно поискать их видеообзоры, на CodePen - демо, в Google - текстовые туториалы. При этом принимайте во внимание, что библиотеки обновляются и инструкции со временем устаревают. Поэтому наиболее надёжным и достоверным источником информации о работе библиотеки является её документация, с которой вам предстоит разобраться самостоятельно.

Было бы оптимально, если бы уже на этапе фиксированной вёрстки вы верстали выбранный вами слайдер, а не просто картинку с квадратиками и стрелочками под ней. Тогда на этапе добавления js, вы сможете сосредоточиться на js, а не переделывать данный блок с нуля.

#### 2. Section Visiting. Google Street View

В проекте используется семь [Google Street View](https://github.com/rolling-scopes-school/stage1-tasks/blob/museum/README.md#используемые-в-макете-ссылки): шесть из них открываются в отдельных вкладках при клике по карточкам секции `Visiting`, седьмая - при клике по кнопке `Discover the Louvre`  секции `Welcome`.  

Вам необходимо встроить Google Street View на страницы своего сайта. Для этого в папке проекта создайте папку `tours` и в ней разместите семь html-файлов `tour1.html`, `tour2.html` и т.д. В каждом из этих файлов создайте базовую структуру html. В VS Code для этого достаточно поставить в html-документе восклицательный знак и нажать клавишу `Tab`.

**Обратите внимание!** Если вы используете школьную сборку webpack, все html-файлы должны находиться в корне, на одном уровне с `index.html`, не вложенными в другие папки. Т.е. папку `tours` не создаёте, и файлы `tour1.html`, `tour2.html` и т.д. размещаете в папке `src`.

Откройте ссылку на Google Street View, нажмите на три точки слева вверху [скрин1](../images/panorama1.png), кликните по строке "Поделитесь с друзьями или получите код изображения", выберите вкладку "Встраивание карт", нажмите "Копировать HTML" [скрин2](../images/panorama2.png), вставьте скопированный код в тело вашего html-документа.

По умолчанию размер панорамы 600х450рх. Вам необходимо, чтобы панорама полностью занимала страницу браузера без отступов по краям. Для этого используйте css-стили.

Когда панорама готова, ссылку на неё необходимо добавить в ваш landing page.  
Ссылки на html-страницы формируются точно так же, как ссылки на картинки, иконки, видео и т. д. и будут выглядеть примерно так 
```html
<a href="tours/tour1.html" target="_blank">Код карточки или кнопки</a>
```

Атрибут `target="_blank` нужен для того, чтобы ссылка открывалась в новой вкладке.

#### 3. Section Video. Playlist
Плейлист видео это тот же слайдер, который вы планируете использовать в секции `Welcome`. Основных отличий два: на странице одновременно отображаются три слайда (но пролистываются они по одному) и вместо изображений слайды содержат встроенное видео с YouTube.

Видео с YouTube встраиваем уже на этапе вёрстки.  
Туториал по встраиванию видео: [Добавляем YouTube видео на сайт](https://active-vision.ru/blog/youtube-video-na-sayt/), раздел "Как вставить видео YouTube на сайт".  
[Ссылки на видео](https://github.com/rolling-scopes-school/stage1-tasks/blob/museum/README.md#секция-video) - встраиваем первые три  
[Постеры видео](https://github.com/rolling-scopes-school/stage1-tasks/tree/museum) находятся в папке assets подпапке video. Для скачивания нажимаем зелёную кнопку `Code` - `Download ZIP`

При создании слайдера обратите внимание, чтобы ваш сайт не загружал одновременно все YouTube видео, это может замедлить его работу. Используйте отложенную загрузку iframe при помощи атрибута `loading="lazy"`. С его работой можно ознакомиться в статье [Пришло время ленивой загрузки закадровых <iframe>](https://habr.com/ru/post/512508/)

#### 4. Section Gallery
[Изображения для галереи](https://github.com/rolling-scopes-school/stage1-tasks/tree/museum) - можно скачать с гитхаба: папка assets => подпапка img => подпапка galery.  
Всего изображений 15. Их особенность - разная высота при одинаковой ширине, благодаря этому на странице они напоминают каменную кладку. Изображения размещаются в секции `Gallery` в три колонки (при добавлении адаптивности количество колонок уменьшится до двух). При этом только часть изображений отображается на странице, остальные скрыты за границами секции.

Для вёрстки данной секции рекомендуется использовать флексы или гриды, при этом дополнительные обёртки для каждой колонки использовать нежелательно.  
Указать расстояния между изображениями по горизонтали и вертикали можно при помощи css-свойств `row-gap` и `column-gap`.  
Разместить изображения в три колонки можно также при помощи [css-модуля columns](https://html5book.ru/css3-columns/)


Чтобы отобразить на странице только часть изображений, вам понадобится два блока:
```html
<div class="picture-container">
  <div class="picture-inner-container">
  </div>
</div>
```
Внешний блок `picture-container` имеет заданные на макете размеры и свойство `overflow-y: hidden;` благодаря которому обрезает размер внутреннего вложенного в него блока по высоте. 

Высота внутреннего блока `picture-inner-container` должна быть достаточной, чтобы в него в одну колонку поместились пять самых высоких изображений. Именно в этот блок вкладываем изображения галереи. 

#### 5. Section Gallery. JavaScript
После того как секция `Gallery` полностью свёрстана и стилизована, переходим к выполнению пункта требований "при перезагрузке (обновлении) страницы картины в блоке `Galery` отображаются в рандомном порядке". Для этого нам необходимо реализовать динамическую подгрузку изображений при помощи JavaScript. 

Так как js-кода в приложении планируется много, для каждой секции с интерактивностью рекомендуется создать свой отдельный js-файл, в данном случае gallery.js. Этот файл необходимо подключить к вёрстке перед закрывающим body. 
```html
<script src="js/gallery.js"></script>
```

Подключение всех js-файлов в html исторически самый первый способ, который в современной разработке заменило использование js-модулей. В данном таске использование js-модулей обязательным не является, обзорную информацию о js-модулях можно найти [ниже](#8-js-modules).

Удалим все теги `img` из блока `picture-inner-container` и добавим их динамически.
Для этого при помощи метода `document.querySelector()` находим блок `picture-inner-container`

```js
const pictureInnerContainer = document.querySelector('.picture-inner-container');
```

Создадим элемент `img` добавим ему класс, src, alt-атрибут и добавим в контейнер

```js
const img = document.createElement('img');
img.classList.add('gallery-img')
img.src = `assets/img/galery/galery1.jpg`;
img.alt = `galery1`;
pictureInnerContainer.append(img);
```

Мы создали элемент `img` и добавили его на страницу.  
Такой же результат можно получить использовав шаблонную строку:

```js
const img = `<img class="gallery-img" src="assets/img/galery/galery1.jpg" alt="galery1">`;
pictureInnerContainer.innerHTML = img;
```

Чтобы добавить все изображения, создайте массив с их адресами, рандомно перемешайте его функцией [shuffle(array)](https://learn.javascript.ru/task/shuffle) и используя метод `.map()` пройдитесь по массиву, добавляя каждое изображение в контейнер.

Объедините весь код в одну функцию и вызовите её. Теперь каждый раз при перезагрузке страницы у вас будет новое рандомное расположение изображений в галерее.

#### 6. Booking ticket form
Вёрстка форм - важная часть создания веб-страниц. Формы обеспечивают взаимодействие пользователя с веб-сервером, позволяют оставить отзыв, сделать заказ, произвести оплату. 

Ознакомьтесь с особенностями вёрстки форм: [Формы и поля в HTML](https://guruweba.com/html/formy-i-polya-v-html-vse-o-html-formakh/), [HTML Формы](https://html5css.ru/html/html_forms.php)

Стилизация элементов формы - сложная задача, требующая глубоких знаний css (или хороших навыков поиска информации в интернете).  

Самые полезные сайты, которые помогут вам в этой задаче: 
- stackoverflow.com, где собрано множество ответов на вопросы 
- codepen.io с огромным количеством примеров кода.

#### 7. Parallax
Параллакс - несложный в реализации, но очень эффектно выглядящий элемент сайта.  
Всё, что требуется для создания параллакса:
- создать `div`
- указать ему ширину 100% и фиксированную высоту
- добавить фоновое изображение и указать ему свойства

```css
   background-size: cover;
   background-attachment: fixed;
```

За магию отвечает последнее из них. При прокрутке страницы фон параллакса остаётся неподвижным, благодаря чему обеспечивается интересный и необычный визуальный эффект.

#### 8. JS-modules
Особенности js-модулей рассматриваются в небольшом 10-минутном видео [Модули в JavaScript](https://youtu.be/VtEwDiC5npA)

**Подключение js-модулей к проекту**.  
Есть один общий js-файл index.js с типом `type="module"` и только он один подключается к html:
```html
<script type="module" src="index.js"></script>
```
Остальные js-файлы импортируются(подключаются) в index.js.  
Такой модульный подход будет работать только на сервере. Live Server подойдёт.  

Если в подключаемом js-файле есть только одна функция, которую нужно экспортировать, для её экспорта используем директиву `export default`
```js
// gallery.js
export default singleFn;
``` 
Импорт в index.js в этом случае выглядит так
```js
// index.js
import singleFn from './js/gallery.js';
```  
Если в подключаемом js-файле много функций, которые нужно экспортировать, перед каждой пишем директиву `export `
```js
// gallery.js
export function fn1() {...} 
export function fn2() {...}
``` 
Импорт в index.js в этом случае выглядит так
```js
// index.js
import * as galleryFn from  './js/gallery.js';
```  
Использовать подключенные таким образом функции можно так
```js
// index.js
import * as galleryFn from  './js/gallery.js';

galleryFn.fn1();
galleryFn.fn2();
```

#### 9. Webpack
Если вы используете js-модули, или добавляете стили с использованием sass (или другого css-препроцессора), или просто хотите научиться новому, для сборки проекта рекомендуется использовать Webpack.

Для студентов rs school создана отличная очень простая и удобная сборка https://www.npmjs.com/package/create-rss-app

**Инструкция по настройке:**
- откройте терминал в папке, где хотите создать проект
- выполните команду `npx create-rss-app project-name` 
- дождитесь установки
- перейдите в папку с проектом `cd project-name`
- запустите dev-сервер `npm start`

**Структура проекта:**
- файлы проекта хранятся в папке `src`
- в папке `src` **обязательно** должны быть файлы `index.html` и `index.js`
- css-стили подключаются в `index.html`, как старые времена) 
- можно использовать sass/scss, их подключаем импортом в JS
- картики/звуки так же хранятся в папке src, структура любая, будут скопированы "как есть"

**Сборка и деплой проекта:**  
- когда работа над проектом закончена, выполните команду `npm run build`
- в папке с проектом появится папка `dist` с собранными файлами вашего приложения
- команду `npm run build` можно выполнять много раз, файлы в папке `dist` при этом будут обновляться
- чтобы задеплоить проект на `gh-pages`, переименуйте папку `dist`, укажите в качестве названия папки название вашего приложения
- загрузите переименованную папку с собранными файлами приложения в ветку `gh-pages` приватного репозитория школы. 
- задеплоенная версия приложения будет доступна по ссылке 
```https://rolling-scopes-school.github.io/repository-name/folder-name```
где
- `repository-name` - название репозитория
- `folder-name` - название папки с файлами приложения

**Загрузка файлов в репозиторий**  
- клонируете ветку `gh-pages` репозитория себе на компьютер. Для этого в Git Bash выполняете команду  
```git clone ссылка на репозиторий -b gh-pages```  
- перетягиваете в папку репозитория папку с собранными файлами приложения 
индексируете изменения. Для этого выполняете команду  
```git add .``` (с точкой в конце)  
- коммитите изменения. Для этого выполняете команду  
```git commit -m "пишете что изменили"```  
- загружаете файлы в репозиторий. Для этого выполняете команду  
```git push origin gh-pages``` , здесь `gh-pages` - название ветки репозитория, в которую пушите изменения